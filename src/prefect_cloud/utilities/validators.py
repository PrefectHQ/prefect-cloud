"""
This module contains a collection of functions that are used to validate the
values of fields in Pydantic models. These functions are used as validators in
Pydantic models to ensure that the values of fields conform to the expected
format.
This will be subject to consolidation and refactoring over the next few months.
"""

from __future__ import annotations

import re

from collections.abc import Mapping, MutableMapping
from typing import Any, Optional, TypeVar, overload
from uuid import UUID

import jsonschema
import pendulum
import pendulum.tz


T = TypeVar("T")
M = TypeVar("M", bound=Mapping[str, Any])
MM = TypeVar("MM", bound=MutableMapping[str, Any])


LOWERCASE_LETTERS_NUMBERS_AND_DASHES_ONLY_REGEX = "^[a-z0-9-]*$"
LOWERCASE_LETTERS_NUMBERS_AND_UNDERSCORES_REGEX = "^[a-z0-9_]*$"


@overload
def raise_on_name_alphanumeric_dashes_only(
    value: str, field_name: str = ...
) -> str: ...


@overload
def raise_on_name_alphanumeric_dashes_only(
    value: None, field_name: str = ...
) -> None: ...


def raise_on_name_alphanumeric_dashes_only(
    value: Optional[str], field_name: str = "value"
) -> Optional[str]:
    if value is not None and not bool(
        re.match(LOWERCASE_LETTERS_NUMBERS_AND_DASHES_ONLY_REGEX, value)
    ):
        raise ValueError(
            f"{field_name} must only contain lowercase letters, numbers, and dashes."
        )
    return value


@overload
def raise_on_name_alphanumeric_underscores_only(
    value: str, field_name: str = ...
) -> str: ...


@overload
def raise_on_name_alphanumeric_underscores_only(
    value: None, field_name: str = ...
) -> None: ...


def raise_on_name_alphanumeric_underscores_only(
    value: Optional[str], field_name: str = "value"
) -> Optional[str]:
    if value is not None and not re.match(
        LOWERCASE_LETTERS_NUMBERS_AND_UNDERSCORES_REGEX, value
    ):
        raise ValueError(
            f"{field_name} must only contain lowercase letters, numbers, and"
            " underscores."
        )
    return value


@overload
def validate_parameter_openapi_schema(schema: M, values: Mapping[str, Any]) -> M: ...


@overload
def validate_parameter_openapi_schema(
    schema: None, values: Mapping[str, Any]
) -> None: ...


def validate_parameter_openapi_schema(
    schema: Optional[M], values: Mapping[str, Any]
) -> Optional[M]:
    """Validate that the parameter_openapi_schema is a valid json schema."""
    if values.get("enforce_parameter_schema"):
        try:
            if schema is not None:
                # Most closely matches the schemas generated by pydantic
                jsonschema.Draft202012Validator.check_schema(schema)
        except jsonschema.SchemaError as exc:
            raise ValueError(
                "The provided schema is not a valid json schema. Schema error:"
                f" {exc.message}"
            ) from exc

    return schema


@overload
def default_timezone(v: str, values: Optional[Mapping[str, Any]] = ...) -> str: ...


@overload
def default_timezone(
    v: None, values: Optional[Mapping[str, Any]] = ...
) -> Optional[str]: ...


def default_timezone(
    v: Optional[str], values: Optional[Mapping[str, Any]] = None
) -> Optional[str]:
    values = values or {}
    timezones = pendulum.tz.timezones()

    if v is not None:
        if v and v not in timezones:
            raise ValueError(
                f'Invalid timezone: "{v}" (specify in IANA tzdata format, for example,'
                " America/New_York)"
            )
        return v

    # anchor schedules
    elif "anchor_date" in values:
        anchor_date: pendulum.DateTime = values["anchor_date"]
        tz = "UTC" if anchor_date.tz is None else anchor_date.tz.name
        # sometimes anchor dates have "timezones" that are UTC offsets
        # like "-04:00". This happens when parsing ISO8601 strings.
        # In this case we, the correct inferred localization is "UTC".
        return tz if tz in timezones else "UTC"

    # cron schedules
    return v


def validate_cron_string(v: str) -> str:
    from croniter import croniter

    # croniter allows "random" and "hashed" expressions
    # which we do not support https://github.com/kiorky/croniter
    if not croniter.is_valid(v):
        raise ValueError(f'Invalid cron string: "{v}"')
    elif any(c for c in v.split() if c.casefold() in ["R", "H", "r", "h"]):
        raise ValueError(
            f'Random and Hashed expressions are unsupported, received: "{v}"'
        )
    return v


def validate_default_queue_id_not_none(v: Optional[UUID]) -> UUID:
    if v is None:
        raise ValueError(
            "`default_queue_id` is a required field. If you are "
            "creating a new WorkPool and don't have a queue "
            "ID yet, use the `actions.WorkPoolCreate` model instead."
        )
    return v


### BLOCK SCHEMA VALIDATORS ###


def validate_name_present_on_nonanonymous_blocks(values: M) -> M:
    # anonymous blocks may have no name prior to actually being
    # stored in the database
    if not values.get("is_anonymous") and not values.get("name"):
        raise ValueError("Names must be provided for block documents.")
    return values


@overload
def validate_block_document_name(value: str) -> str: ...


@overload
def validate_block_document_name(value: None) -> None: ...


def validate_block_document_name(value: Optional[str]) -> Optional[str]:
    if value is not None:
        raise_on_name_alphanumeric_dashes_only(value, field_name="Block document name")
    return value


def validate_block_type_slug(value: str):
    raise_on_name_alphanumeric_dashes_only(value, field_name="Block type slug")
    return value
